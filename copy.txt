# ============================================================================
# core/processor.py
# ============================================================================

from typing import List, Dict
from collections import defaultdict
import statistics

logger_proc = setup_logger('processor')

class DataProcessor:
    """Processes and aggregates market data"""
    
    @staticmethod
    def remove_outliers(prices: List[float]) -> List[float]:
        """
        Remove price outliers using percentile filtering
        More aggressive filtering to remove unrealistic high prices
        """
        if len(prices) < 3:
            return prices
        
        sorted_prices = sorted(prices)
        
        low_idx = int(len(sorted_prices) * (OUTLIER_PERCENTILE_LOW / 100))
        high_idx = int(len(sorted_prices) * (OUTLIER_PERCENTILE_HIGH / 100))
        
        if high_idx <= low_idx:
            high_idx = low_idx + 1
        
        filtered = sorted_prices[low_idx:high_idx]
        
        if not filtered:
            return prices[:1] if prices else prices
        
        logger_proc.debug(
            f"Filtered {len(prices)} prices to {len(filtered)} "
            f"(removed {len(prices) - len(filtered)} outliers)"
        )
        return filtered
    
    @staticmethod
    def aggregate_items(items: List[MarketItem], order_filter: str = 'both') -> Dict:
        """
        Group by item_id and calculate metrics with VOLUME-WEIGHTED pricing
        order_filter: 'both', 'sell', or 'buy'
        """
        aggregated = defaultdict(lambda: {
            'name': '',
            'sell_prices': [],
            'sell_volumes': [],
            'buy_prices': [],
            'buy_volumes': []
        })
        
        # Collect raw prices + volumes
        for item in items:
            agg = aggregated[item.item_id]
            agg['name'] = item.name
            
            if item.order_type == 'sell':
                agg['sell_prices'].append(item.price)
                agg['sell_volumes'].append(item.volume)
            elif item.order_type == 'buy':
                agg['buy_prices'].append(item.price)
                agg['buy_volumes'].append(item.volume)
        
        result = {}
        
        for item_id, data in aggregated.items():
            prices = []
            volumes = []
            
            if order_filter == 'sell':
                prices = data['sell_prices']
                volumes = data['sell_volumes']
            elif order_filter == 'buy':
                prices = data['buy_prices']
                volumes = data['buy_volumes']
            else:
                prices = data['sell_prices'] + data['buy_prices']
                volumes = data['sell_volumes'] + data['buy_volumes']
            
            if not prices or not volumes:
                continue
            
            # --- OUTLIER FILTERING (PRICE-ONLY) ---
            filtered_prices = DataProcessor.remove_outliers(prices)
            
            # Rebuild (price, volume) pairs after filtering
            filtered_pairs = [
                (p, v) for p, v in zip(prices, volumes)
                if p in filtered_prices
            ]
            
            if not filtered_pairs:
                continue
            
            filtered_volume = sum(v for _, v in filtered_pairs)
            if filtered_volume <= 0:
                continue
            
            # --- VOLUME-WEIGHTED AVERAGE PRICE ---
            avg_price = sum(p * v for p, v in filtered_pairs) / filtered_volume
            
            total_volume = sum(volumes)
            value_score = total_volume * avg_price
            
            result[item_id] = {
                'name': data['name'],
                'total_volume': total_volume,
                'avg_price': avg_price,
                'value_score': value_score,
                'sell_orders': len(data['sell_prices']),
                'buy_orders': len(data['buy_prices'])
            }
        
        logger_proc.info(
            f"Aggregated {len(result)} unique items "
            f"(filter: {order_filter}, volume-weighted pricing)"
        )
        return result